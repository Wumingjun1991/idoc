# 正则

## 概念

* 正则就是一个规则,一个用来处理字符串的规则
* 正则只能用来处理字符串

## test(匹配)

* 判断一个字符串是否符合我们制定的规则
* reg.test(str)
* 返回值有两个,true(匹配)和false(不匹配)

## exec(捕获)

* 把字符串中符合我们正则规则的内容捕获到
* reg.exec(str)
* 捕获的两个阶段: 先匹配,判断字符串是否匹配规则,如果匹配不成功返回null,如果字符串内容匹配的话,把匹配的字符串中的内容捕获出来,返回一个数组
* 捕获到字符串后返回值是一个数组:[第一项:捕获出的内容,index:捕获的内容的首字符在原字符串中的索引,input:原字符串]

## 正则的创建

* 字面量方式创建: var reg = /^$/;
* 实例创建方式: var reg = new RegExp("");
* 两种创建方式的区别:
   * 字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接,而在实例创建的方式是可以的
   * 字面量方式中直接写\d就可以,而在实例中需要把它转译 \\d
* 对于需要进行变量拼接的需求,只能使用实例创建的方式

## 元字符

* 每一个正则表达式都是由元字符和修饰符组成的
* 一个元字符只能匹配一个字符 
* 正则中可以没有修饰符,但是元字符必须要有
* 在两个//之间具有意义的一些字符
* 在[]中除了^和-和\其他字符都没有特殊意义
* []不识别两位数,在[]中^的意思是取反
* 在[]中,如果想让-表示它本身的意思,只要把-写在最后就可以
* RegExp.$n: 正则第n个分组捕获的内容,如果是在字符串中可以直接写$n,但是单独写的话必须是RegExp.$n这种格式
* 具有特殊意义的元字符
   * \: 转义字符,转译后面字符所代表的含义
   * ^: 以某一个元字符开始
   * $: 以某一个元字符结尾
   * \n: 匹配一个换行符
   * .: 除了\n以外的任意字符
   * (): 分组,把一个大正则划分成几个小正则(改变默认优先级)
   * x|y:x或者y中的一个
   * [xyz]: x或者y或者z中的一个
   * [^xyz]: 除了三个以外的任何一个字符
   * [a-z]: a-z之间的任何一个字符
   * [^a-z]: 除了a-z之间的任何一个字符
   * \d: 一个0-9之间的任何一个数字
   * \D: 除了0-9之间的数字以外的任何字符
   * \b: 匹配一个边界符,\b不能出现在两个字符串中间
   * \w: 数字,字母,下划线中的任意一个字符
   * \s: 匹配一个空白字符(空格,制表符,换页符...)
* 代表出现次数的量词元字符
   * *: 出现零到多次
   * +: 出现一到多次
   * ?: 出现零次或者一次
   * {n}: 出现n次
   * {n,}: 出现n到多次
   * {n,m}: 出现n到m次
* 所有中文字的utf编码:u4e00-u9fa5   

## 修饰符

* 写在//后面的叫修饰符,只有三种
* global(g): 全局匹配
* ignoreCase(i): 忽略大小写匹配
* multiline(m): 多行匹配

## 正则的懒惰性

* 捕获字符串的时候,只会捕获第一次匹配的内容,在不进行任何处理的情况下,在执行多次捕获,捕获的还是第一次匹配的内容
* 正则中有一个属性叫lastIndex,它表示的是正则每一次捕获在字符串中开始查找的位置,默认值是0
* 通过加上全局修饰符g,正则每一次捕获结束后,lastindex值都会改变,所以可以捕获整个字符串中所有的匹配内容

## 正则的贪婪性

* 捕获字符串的时候,虽然只会捕获一次匹配的内容,但是会把匹配的字符串整个都捕获出来
* 通过在量词元字符后面加上一个?可以解决正则的贪婪性
* 在小括号内的最前面加一个?: 表示只匹配不捕获
* 因为在小括号内?: 表示的是只匹配不捕获,所以后面不能用\1来代表这个分组中的内容

## match

* match是字符串的方法
* 语法: str.match(正则表达式)
* 用match的时候,正则表达式必须加上修饰符,否则就和exec的结果一样了
* 有分组的时候正则加上修饰符g,捕获不到分组的内容,如果不加修饰符g,则和exec一样,只能捕获一次
* match返回值是一个数组,但是没有index和input这两个属性

## 正则在字符串方法中的应用

* str.search(正则): 返回正则匹配的字符的首字符的索引,没有则返回-1
* str.split(正则): 按照正则匹配的字符拆分为数组

## 分组捕获

* exec返回值:
   * 第一项: 大正则捕获的内容
   * 第二项: 第一个分组捕获的内容
   * 第三项: 第二个分组捕获的内容
   * 大正则中每一个分组都会单独返回一个内容
   * index: 第一项中大正则捕获的内容的首字符索引
   * input: 原字符串
* 有分组的情况下,想要获取分组的内容只能使用exec方法

## 字符串几个重要方法

* search(RegExp): 按照正则匹配的字符查找字符,返回值是首字符的索引,没有找到则返回-1
* split(RegExp): 按照正则匹配的字符进行拆分为数组,返回值是一个字符串拆分后的数组
* replace(RegExp,''): 使用正则加上修饰符g可以一次性替换整个字符串中的某一些字符
* replace(RegExp,function(){}): replace中的第二个参数可以传一个函数,每替换一次就会执行一次,每一次执行都会传入几个参数
   * arguments[0]: 大正则匹配的内容
   * arguments[1]: 第一个分组匹配的内容
   * arguments[2]: 第二个分组匹配的内容,以此类推
   * 倒数第二个参数: 大正则匹配的内容首字符的索引
   * 最后一个参数: 原字符串
   * 函数中return的值就是替换大正则捕获的内容
   
## 括号表达式

* 保证一些操作语法能被浏览器识别
* (function(){})(): 自执行函数
* 基本数据类型中的数字不能直接调取属性和方法(数字后面出现的第一个点会被认为是小数点),例如:1.toString(错误),应写成: 1..toString或者(1).toString
* 引用数据类型中的对象不能直接调用方法和属性,必须通过对象名.属性名或者是({}).属性名,例如:

```javascript
   var obj = {a:1,b:2};
   console.log(obj.a);
   console.log(({a:1,b:2}).a);
```

* 在用eval遇到{}表示对象的时候用小括号包起来
* 计算的时候括号中的优先级最高
* 在正则中()表示小分组,优先级也高
* ()本身也有计算的效果
* 一个括号中如果包含多项,则只会copy最后一项的值,再进行后续处理,例如:

```javascript
   var a = (1,2,3,4);
   console.log(a);//==>4;
```
   
* 如果在()中的最后一项是一个函数,那么函数执行的时候里面的this只会是window,例如:

```javascript
  var f1 = function() {  console.log(this);};
  var f2 = function() {  console.log(this);};
  var obj = {f1:f1,f2:f2};
  (f1,f2)(); //==> f2();
  (f1,f2,obj,f1)();//==>f1();
  (obj.f1)();//==>obj.f1();  如果括号中只有一项内容,那么和不加括号没有区别
```