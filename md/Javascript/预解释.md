# 预解释(变量提升)

## 预解释

* 在当前作用域形成之后,在JS代码执行之前,浏览器首先会默认的把所有带var和function的进行提前的声明或者定义
* 声明(declare): 告诉浏览器在当前作用域中有一个叫xxx的变量,如果一个变量只声明了但没有赋值,默认值是undefined
* 定义(defined): 给变量进行赋值
* var: 在预解释的时候只是提前的声明
* 在全局作用域中,带var的变量会进行预解释,在赋值之前执行是不会报错的,不带var的不会进行预解释,在赋值之前执行会报错
* 不带var的变量声明相当于给window增加了一个属性名和属性值
* 带var的变量声明相当于给全局作用域增加了一个全局变量,不仅如此,还相当于给window增加了一个属性名和相应的属性值
* function: 在预解释的时候声明和定义都完成了
* 预解释只发生在当前作用域下
* 函数的执行可以写在函数的定义前面,因为预解释的时候函数就已经声明和定义了
* 在JS中如果不进行任何特殊处理的情况下,如果上一行代码报错,后面的代码都不再执行

## 作用域

* 全局作用域: window下,一打开浏览器就会形成
* 私有作用域: 一个函数执行就是一个私有作用域,函数执行的时候这个私有作用域就会形成
* 私有作用域下的私有变量外界访问不到,但是私有作用域中可以获取外界的变量

## 内存的分类

* 栈内存: 用来提供一个供JS代码执行的环境,全局作用域和私有作用域
* 堆内存: 用来存放引用数据类型,例如对象数据类型存的键值对和函数数据类型存的代码字符串

## 内存的销毁机制

* 堆内存: 只要这个堆内存没有被任何变量或者属性占用,浏览器就会主动将他销毁,其他的需要手动销毁
* 在项目中,遇到一个对象后面不用了,手动清空一下,obj = null
* 栈内存(作用域): 全局作用域在关闭浏览器的时候被销毁,在项目中尽量避免全局变量的使用
* 私有作用域中相同的函数每一次执行都会形成一个私有作用域,他们之间没有任何关系
* 立即销毁: 函数没有返回值,或者返回值的内容没有被占用,浏览器就会把它销毁
* 暂时不销毁: 函数返回了一个函数,这个返回的函数接着执行了,完成之后浏览器就会抽时间销毁(不同浏览器的机制不同所以销毁时间不一样)
* 不销毁: 函数执行返回一个地址,一直被外界变量占用着
* 作用域不销毁这个概念主要是用在给元素添加绑定事件的时候

## 函数执行机制

* 形成一个私有作用域
* 如果有形参,先给形参赋值
* 进行私有作用域中的预解释
* 私有作用域中的代码从上到下执行

## 私有变量和全局变量

* 在**全局作用域**下声明(预解释的时候)的变量是全局变量
* 在**私有作用域**中声明的变量和**函数的形参**都是私有的变量

## 作用域链

* 在私有作用域中,当代码执行的时候遇到一个变量时,首先要确定这个变量是否为私有变量,如果是私有变量,那么和外面没有任何关系,如果不是私有的,则往当前作用域的上级作用域进行查找,如果上级作用域也没有则继续查找,直到找到window为止,如果还没有,如果是获取值,则会报错,如果是设置值,则相当于给window增加了一个属性值和属性名

## 查找上级作用域

* 看这个函数当前对应的堆内存在哪个作用域下定义的,那么他的上一级就是这个作用域,跟在哪里执行没关系

## 闭包

* 函数执行的时候形成的私有作用域保护了里面的私有变量不受外界干扰(外面修改不了私有的,私有的也修改不了外面的),我们把这种机制叫做闭包

## 毫无节操的预解释

* 在if判断中,预解释的时候不管条件是否成立,都会把带var的进行提前声明
* 预解释只预解释等号左边的,右边的是值,不参与预解释
* 自执行函数在全局作用域下不进行预解释,当代码执行到这个位置的时候定义和执行一起完成
* 函数体中return下面的代码虽然不再执行,但是会进行预解释,return出的内容执行但是不进行预解释
* 在JS中如果变量的名字和函数的名字重复了,也算冲突
* 在预解释的时候,如果名字已经声明过了,不需要重新声明,但是需要重新定义 



