# 预解释(变量提升)

## 什么是预解释

* 在当前作用域下,在JS代码执行之前,浏览器首先会默认的把所有带var和function的进行提前的声明或者定义
* 声明(declare): 告诉浏览器在当前作用域中有一个叫xxx的变量,如果一个变量只声明了但没有赋值,默认值是undefined
* 定义(defined): 给变量进行赋值
* var: 在预解释的时候只是提前的声明
* 在全局作用域中,带var的变量会进行预解释,在赋值之前执行是不会报错的,不带var的不会进行预解释,在赋值之前执行会报错
* 不带var的变量声明相当于给window增加了一个属性名和属性值
* 带var的变量声明相当于给全局作用域增加了一个全局变量,不仅如此,还相当于给window增加了一个属性名和相应的属性值
* function: 在预解释的时候声明和定义都完成了
* 预解释只发生在当前作用域下
* 函数的执行可以写在函数的定义前面,因为预解释的时候函数就已经声明和定义了
* 在JS中如果不进行任何特殊处理的情况下,如果上一行代码报错,后面的代码都不再执行

## 内存的分类

* 栈内存: 用来提供一个供JS代码执行的环境,全局作用域和私有作用域
* 堆内存: 用来存放引用数据类型,例如对象数据类型存的键值对和函数数据类型存的代码字符串

## 函数执行机制

* 形成一个私有作用域
* 如果有形参,先给形参赋值
* 进行私有作用域中的预解释
* 私有作用域中的代码从上到下执行

## 私有变量和全局变量

* 在**全局作用域**下声明(预解释的时候)的变量是全局变量
* 在**私有作用域**中声明的变量和**函数的形参**都是私有的变量

## 作用域链

* 在私有作用域中,代码执行的时候遇到了一个变量,首先要确定这个变量是否为私有变量,如果是私有变量,那么和外面没有任何关系,如果不是私有的,则往当前作用域的上级作用域进行查找,如果上级作用域也没有则继续查找,直到找到window为止,如果还没有,如果是获取值,则会报错,如果是设置值,则相当于给window增加了一个属性值和属性名

## 闭包

* 函数形成的私有作用域保护了里面的私有变量不受外界干扰(外面修改不了私有的,私有的也修改不了外面的)

## 毫无节操的预解释

* 在if判断中,预解释的时候不管条件是否成立,都会把带var的进行提前声明
* 预解释只预解释等号左边的,右边的是值,不参与预解释
* 自执行函数在全局作用域下不进行预解释,当代码执行到这个位置的时候定义和执行一起完成
* 函数体中return下面的代码虽然不再执行,但是会进行预解释
* 在JS中如果变量的名字和函数的名字重复了,也算冲突
* 在预解释的时候,如果名字已经声明过了,不需要从新声明,但是需要重新赋值



