# 函数

## 函数的概念

* 函数可以一次定义多次调用,并且互相不会影响
* 在js中function的一个特别大的作用：将实现一个功能的代码进行封装，以后如果用到了这个功能，代码没有必要重新写了，只需要执行这个方法就好了(封装)

## 函数的组成

* 相当于一个方法或者一个功能
* functionfn(){}：定义一个函数，大括号中的就是函数体，即一个功能或一个方法实现的步骤
* 定义一个函数的步骤：开辟一个新的空间地址，把函数体中的js代码当作字符串存到空间中(一个函数如果只是定义了，并没有执行的话，这个函数没有任何意义)，再把这个空间地址给这个函数名
* 形参：小括号中的量(可以理解为一个变量)，通过参数的不同实现不同的功能(一个功能的多种形态)
* 形参的作用：实现一个功能，发现部分原材料没有，在制定计划的时候我们没有办法获取，我们就把需要的原材料定义在我们的形参上，在执行计划的时候，把原材料提供就好了
* 定义一个形参变量，执行的时候没有传递值，那默认值是undefined
* fn()：执行这个函数，首先会形成一个私有地盘，然后把定义的时候，存在空间的js代码字符串当作代码执行
* 如果函数中出现了this,this指的是当前操作的这个对象

## 函数的基本应用

* 定义函数:关键字 函数名(){要执行的js代码块}
* 执行函数:函数名()
* 函数名后面没有括号,这个函数名就是一个代表整个函数的变量,用来代表函数和储存函数
* 私有变量: 函数内定义的变量,函数外不能获取到,如果想让外界获取这个变量代表的值,需要将这个变量代表的值返回到函数外
* 函数名后面加了括号,代表函数执行完成,接收到的是返回值,此处的返回值如果没有设定,接收值为undefined,如果设定,设定的是什么接收的就是什么
* arguments也是一个类数组(有数字作为索引，索引从0开始代表第几个传递的参数，还有一个length的属性，代表传递了多少个参数 )
* callee：arguments.callee代表的就是当前函数的本身
* 函数执行的时候，会形成一个私有的地盘(函数里面定义的变量，在外面不能直接使用)
* 闭包：函数执行的时候会形成一个新的私有的作用域，来保护里面的变量不受外界的干扰，我们把这种保护机制叫做闭包

## 函数的参数

* 形参:用来接收实参的变量,用来代表和储存实参
* 实参:传入到函数内具体的值
* 形参和实参是一一对应的关系,如果形参定义而实参没有传值,那么形参的返回值是undefined
* 形参相当于只是声明了变量,但没有赋值,传入实参后,形参被赋值
* 所有函数都有一个length的属性,表示函数的参数
* 函数接收实参的方法:形参和arguments 

## arguments对象'object'

* arguments：函数内置接收参数的机制(天生自带的，不管你是否传递了参数，也不管有是否写形参，arguments一直存在)
* arguments获取到的是一个实参的集合,将获取到的实参放在一个中括号中,每一个实参之间用逗号隔开,例如[1,2,3,4,5]
* arguments是一个对象,它所获取的每一个对象都有相应的属性名和属性值,中括号中的就是属性值,属性名就是从零开始的一串数字,和属性值一一对应,我们把这个属性名叫做索引
* arguments获取其中的某一个只能用arguments[索引],不能用其他方式

## return

* 利用return将需要获取的这个变量返回到函数外,用函数名()来进行接收,**return只能返回变量所代表的值而不能返回变量名**
* 在函数体中return后面的代码不会执行
* return将值返回到函数外面
* return返回的值用函数执行来接收
* return返回的值只有一个
* return还能用于控制函数体中的代码执行到指定位置结束
* 如果没有写return或者return后面没有写值的话，默认的返回结果是undefined

## 匿名函数

* 给元素绑定事件
* 把函数当作参数(定时器,sort,forEach,map....)
* 匿名函数之函数表达式：把一个匿名函数的定义部分当作一个值赋值给一个变量或者一个元素的事件

## 自执行函数

* 定义和执行一起完成
* 格式：
(function(){})();最常用的
~function(){}();
!function(){}();
+function(){}();
-function(){}();

## this问题

* JS中的this代表的是当前行为执行的主体
* JS中的context(上下文)代表的是当前行为执行的环境(区域)
* this是谁和函数在哪里定义哪里执行都没有任何的关系
* 全局作用域下this就是window
* 自执行函数中的this永远是window
* 给元素绑定事件的时候,给谁绑定事件this就是谁
* 函数执行的时候看前面有没有点,有的话点前面是谁this就是谁,没有点的话this就是window
* 函数作为参数的时候,this是window(例如定时器)
* 在构造函数中,通过this增加的属性都是私有属性

## 函数原型上的call

* 函数原型上的call方法也是一个函数,这个方法至少要传一个参数,这个参数是用来改变call前面的方法的this的
* call方法有两个作用,一个是改变当前函数的this指向,二是让当前的函数执行
* 在非严格模式下,如果不传参数或者传入null或者undefined,默认改变this指向window
* 在严格模式下,如果不传参数或者传入null或者undefined,默认是将this变成undefined
* call方法从第二个参数开始就是给前面函数传的参数
* 当使用两个以上的call方法执行的时候,就相当于把传进来的函数执行
* 当使用函数.call.call()两个以及两个以上的call时,如果传入的参数不是一个函数的话就会报错,因为只有函数的原型上才会有call这个方法

## 函数原型上的apply

* apply和call方法的意思和用法一样,区别是:apply的一个参数也是改变this用的,第二个参数是一个数组,这个数组是给前面的函数传参数的,是将数组中的每一项一个一个传给函数
* 常用于改变参数传递的方式

## bind

* IE低版本不兼容,只改变函数this指向并且返回一个改变后新的函数,原函数不会改变也不会执行
* bind方法常用于事件中

## 严格模式

* "use strict"
* 在严格模式下,函数执行的时候前面没有点,则默认是undefined 

## 回调函数

* 通过参数的形式传进去执行的都是回调函数,是异步的

