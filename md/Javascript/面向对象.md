# 面向对象编程思想

> 所有的编程语言都是面向对象开发的

## 面向对象

* 面向对象开发,也是面向类的开发
* 在JS中万物皆对象
* 在JS中类分两种,一种是内置类,另一种是自定义类
* 内置类: 每一种数据类型都有自己所属的类;Number,String,Boolean,Null,Array,Object,Date,ArrayRegExp,Function(注意:Math不是一个类,它只是一个对象)
* 每一个元素都有自己所属的类
* 自定义类: 

## 单例模式

* 把描述同一个事物(同一个对象)的属性和方法放在一个内存空间下,起到了分组的作用,这样不同事物之间的属性即使属性名相同,相互也不会发送冲突,这个分组编写的模式叫做"单例模式"
* 在单例模式中,对象名也叫做"命名空间"
* 单例模式是一种项目开发中经常使用的模式,因为项目中我们可以使用单例模式来进行"模块化开发"
* 模块化开发: 对于一个相对来说比较大的项目,需要多人协作的开发,我们一般情况下会根据当前项目的需求划分成几个功能板块,每个人负责一部分,同时开发,最后把每个人的代码进行合并
* 单例模式虽然解决了分组的作用,但是不能实现批量的生产,属于手工作业模式
* 单例模式就是一个对象,主要用于解决命名冲突问题,单例模式的函数之间可以用this互相调用,this就是那个单例模式对象

## 工厂模式

* 把实现同一件事情的相同代码放在同一个函数中,以后如果再想实现这个功能就不需要重新编写这些代码了,只需要执行当前的函数即可
* 工厂模式又叫做函数的封装
* 低耦合高内聚: 减少页面中的冗余代码,提高代码的重复利用率
* JS只有重写(相同函数名会覆盖)没有重载(根据参数的不同实现不同的功能)

## 构造函数模式

* 构造函数模式其实就是构造一个类,因为类本身就是函数数据类型的,通过创建一个函数来表示一个类(自定义类),这就是构造函数模式
* 构造函数的函数名首字母最好大写
* 普通函数代表的是一个方法,通过构造函数创建的函数代表的是一个类,是一个自定义类
* 构造函数是Function类的一个实例
* var obj = new Fn();new就是构造函数的创建方式,Fn函数就是一个类,obj就是Fn类的一个实例,函数Fn后面的括号加不加都一样
* 构造函数创建过程:
   * 形成一个私有作用域
   * 预解释
   * 自动创建一个实例,this
   * 代码执行的时候,通过this给实例增加私有属性并赋值
   * 会默认将创建好的实例this返回,所以不需要写return
* 通过this给实例增加的是私有属性,每个实例之间的私有属性是私有的不一样
* 构造函数中会默认的把this的属性返回,所以不用写return,如果写了,写的是基本数据类型话没有影响,如果写的是引用数据类型就会覆盖this返回的属性
* 实例识别: 构造函数模式中拥有类和实例的概念,并且实例和实例之间是相互独立开的

## 原型模式

* 实例通过this得到的是私有属性和方法,还可以继承所属类的共有属性和方法,比如说每个数组都可以用sort这个方法,这个方法是在类Array原型上,因为所有的数组都是Array类的一个具体的实例,所以只要是数组都可以用
* 基于构造函数模式的原型模式解决了方法或者属性公有的问题:把实例之间相同的属性和方法提取成公有的属性和方法
* .prototype 设置公有属性和方法
* 每一个函数数据类型(普通函数,类)都有一个天生自带的属性:prototype(原型),里面存储的是共有的属性和方法,并且这个属性是一个对象数据类型的
* 在prototype上浏览器天生给它加了一个属性constructor(构造函数),属性值是当前函数(类)本身
* 每一个对象数据类型(普通对象,实例,prototype...)也天生自带一个属性:__ proto __ ,属性值是当前实例所属类的原型(prototype)
* 在原型模式中,this常用的有两种情况:
  * 在类中this.xxx = xxx;this代表当前类的实例
  * 在某一个方法中,看执行的时候'.'前面是什么this就是什么
* null,undefined所属类的原型上没有constrctor  

## 原型链

* object是JS中所有数据类型的基类(最顶层的类)
* 在object.prototype上没有 __ proto __ 这个属性
* 通过对象名.属性名的方式获取属性值的时候,首先在对象的私有属性上进行查找,如果私有中存在这个属性,则获取私有的属性值,如果私有的没有,则通过 __ proto __ 找到所属类的原型(类的原型上定义的属性和方法都是当前实例公有的属性和方法),原型上存在的话,获取的是公有的属性,如果原型上也没有,则继续通过原型上的 __ proto __ 继续向上查找,一直找到Object.prototype为止
* 这种查找的机制就是"原型链模式"
* 在IE浏览器中,原型模式也是同样的原理,但是IE浏览器为了防止通过 __ proto __ 修改了公有属性,所以禁止使用 __ proto __ 
* Object.create(proObj) 创建一个新的对象,并且把proObj作为这个对象的原型,不兼容IE678,因为这个属性是在ECMAscript5中规定的 