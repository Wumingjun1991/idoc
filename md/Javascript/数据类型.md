# 数据类型

## 变量和数据类型

### 变量

* js中的变量是一个抽象的概念，是用来存储值和代表值的
* js中定义一个变量非常简单：var 变量名 = 变量值
* = 是赋值操作，左边是变量名，右边是存储的值
* js中的变量是松散类型的：通过一个var变量名就可以存储任何的数据类型
* 变量只定义不赋值的时候,获取变量返回值是undefined

### 数据类型

* js中的数据类型分类:基本数据类型，引用数据类型
* 基本数据类型:数字(number),字符串(string),布尔(boolean),null,undefined
* 引用数据类型:对象数据类型(object),函数数据类型(function)
* 对象数据类型:数组类(Array),正则类(RegExp),数学类(Math),对象类(Object)

### number数据类型

* number数据类型包括:正数，负数，0，小数，NaN
* NaN:not a number 不是一个有效数字，但是他属于number数据类型
* 当.前面是数字的时候,表示的是数字的小数点,例如:1..toString()
* =是赋值操作，==是判断左右两边是否相等
* 注意:NaN==NaN 是不相等的
* isNaN():检测一个值不是有效数字的命题是否成立，是有效数字返回false，不是有效数字返回true，如果检测的值不是number类型的，浏览器会默认把它转换为number类型，然后再进行判断
* Number():强制将其他的数据类型转换为number类型，如果是字符串，字符串中一定都需要是数字才可以转换,如果传入的值中有一个不属于数字,那么整体否定,Number()的返回值要么是数字,要么是NaN
* Number()/Number('')/Number(' ')返回的结果都是0
* parseInt()/parseInt('')/parseInt(' ')返回的结果都是NaN
* parseInt():非强制数据类型转换，将值从第一个查找到最后一个,将有效数字部分返回,如果中途遇到非有效数字，就不再进行查找了
* parseFloat():和parseInt()的区别:parseFloat()查找的是浮点数,parseInt()查找的是整数
* parseFloat()/parseInt()这两个方法,都是从指定值中分离一部分数字,一般指定的值要么是数字要么是字符串

### boolean数据类型

* boolean包含两种:true(真)和false(假)
* 在js基本数据类型中:0,NaN,"",null,undefined这5个是假的,其余都为真的
* Boolean();将其他类型值转化为布尔类型值
* 在进行布尔运算的时候,传入的值**不需要进行任何的转换**
* &&: 左边值为true时,返回右边值,左边值为false时,返回左边值
* ||: 左边值为true时,返回左边值,左边值为false时,返回右边值 
* ！：一个叹号是取反，首先将值转换为布尔类型，然后取反
* ！！：将其他数据类型转换为boolean类型，相当于Boolean()

### string数据类型

* 字符串:在js中字符串是一个变量,用来储存文本的,用引号包裹,字符串在js中没有任何意义,
* 拼接字符串:将两个字符串用'+'连接起来,如果是用变量来代表字符串的时候,变量不能用引号包起来
* 其他数据类型如果遇到字符串拼接的时候,会默认先转为字符串数据类型(toString),然后再拼接
* {}转换为字符串时,不管{}中有多少内容,都会转换成"[object Object]"
* 字符串有length属性,也有索引,可以通过索引取出某个字符串,索引从0开始
* eval() 可以将字符串转为真正的代码,**如果转化的内容是对象的话,就用小括号包起来,否则浏览器会将它识别为一个代码块而不是对象**


### null和undefined

* null表示"没有对象",即该处不应该有值(现在预留,之后可以添加)
* undefined表示"缺少值",就是此处应该有一个值,但是还没有定义
* null转换为数字为0
* undefined转换为数字为NaN

### Object数据类型

* Objects是引用数据类型中的对象类,每一个我们使用的具体对象都是这个类的一个实例
* 对象类中的实例都是由多组属性名和属性值组成，即多组键值对，或者多个key:value
* 属性名和属性值是用来描述这个对象特征的
* 对象的属性名和属性值都是字符串类型的
* var 对象名={属性名:"属性值"};字面量创建方式
* var 对象名=new Object();实例创建方式(在该类上新建一个实例)
* 对象名.属性名="属性值"/对象名["属性名"]="属性值";给一个对象增加一组属性名和属性值，这两种方式是一样的
* 如果属性名为数字时,只能用"对象名["属性名"]=属性值"的方式来进行添加或者获取,引号可以忽略不写
* 对象名.属性名="属性值"/对象名["属性名"]="属性值";修改原有属性名的属性值，规定一个对象的属性名不能重复，如果之前有就是修改，没有就是增加
* console.log(对象名["属性名"]);console.log(对象名.属性名);获取属性名的属性值，如果属性名不存在，默认返回的结果是undefined
* 对象名.属性名=null;保留属性名,删除属性值(假删除)
* delete 对象名.属性名; 删除整个键值对(真删除)
* 对象中有属性,属性分为自定义属性和内置属性
* 对象创建后自带的属性,就称为内置属性
* 有时候内置属性不能满足需求时,人为的给这个对象上添加一些属性,这些人为添加的属性就称之为自定义属性
* 对象的属性和变量很像,都是用来储存值的容器
* 对象数据类型中，还可以具体的细分为：对象类(Object)，数组类(Array)，正则类(RegExp)，时间类(Date),字符串类(String), 数学函数(Math)
* js中对象，类，实例的区别：对象是泛指，js中万物皆对象，类是对对象具体的细分，实例是类中的一个具体的事物，举个例子:自然界中万物皆对象，所有的东西可以分为：人类，植物类，动物类等等，这其中每个人都是人类中的一个具体的实例

### Math类数据类型

* 执行常见的的算数任务

| 名称 | 描述 |
| :-- | --- |
| Math.abs() | 取绝对值 |

### String类数据类型

* String对象用于处理已有的字符块(空格,换行也是字符)
* 字符串是有长度的
* 字符串类也是对象,也有属性名和属性值,他的属性名是当前字符的索引,索引从0开始,到length-1结束
* charAt(索引) 获取指定位置的字符,返回值为当前索引对应的字符
* charCodeAt(索引) 获取指定索引位置字符对应的ASCII值(Unicode编码)
* substr(n,m) 从索引n开始,截取m个字符
* substring(n,m) 从索引n开始截取到索引m,包含n不包含m
* slice(n,m) 从索引n开始截取到索引m,不包含m,但是此方法支持参数为负值(str.length+负数索引)
* indexOf('指定的字符') 查找指定字符所在字符串的索引值,返回值是该字符第一次出现位置的索引值
* lastindexOf('指定的字符') 查找指定字符所在字符串的索引值,返回值是该字符最后一次出现位置的索引值
* str.toUpperCase() 将字符串中的字母转化为大写
* str.toLowerCase() 将字符串中的字母转化为小写
* replace(oldword,newword) 替换,不会改变原字符串,返回一个修改后的新字符串,只能替换第一次遇到的字符,如果后面还有相同的字符是不能替换后面的字符
* search('指定的字符')  查找指定字符所在字符串的索引值
* match('指定的字符') 查找指定字符所在的位置,返回值为['指定的字符',index:字符的索引,input:'被查找的原字符'],如果找不到返回null
* split('分隔符') 将字符串按照指定分隔符产生成数组,分隔符不会出现在数组中
* 如果不传入分隔符,则会将每一个字符都分隔开
* 如果分隔符不存在于字符串中的时候,会将字符串当作整体一项

### Date数据类型

* Date对象用于处理日期和时间,通过这个对象可以获取本机时间(new Date())


### 运算符

* = 赋值,将等号右侧的值赋值给等号左侧
* += x+=y相当于x=x+y
* ++和-- 操作某个变量递增或者递减
* a++是赋值再运算,++a是先运算再赋值
* == 比较,比较等号左右两侧的值是否相等,如果相等返回true,如果不相等返回false
* === 绝对比较,比较等号左右两侧的值是否相等,两个比较的数据类型如果不一样,肯定不相等
* != 不等于


### 数据类型转换规律

* 对象(object)数据类型转换为数字数据类型步骤:先调用toString()方法把对象转换为字符串,然后再调用Number()方法把字符串转换为数字
* 字符串(string)数据类型转换为数字数据类型:调用Number()方法把字符串转换为数字
* 布尔(boolean)数据类型转换为数字数据类型:调用Number()方法把布尔值转换为数字,true就是1,false就是0
* 空对象{}转换为数字是NaN  
* 空数组[]转换为数字是0
* 空字符串""转换为数字是0  
* 如果只有一个值，判断这个值是真还是假遵循:只有0，NaN，"",null,undefined这五个是假的，其余都是真的
* 如果是两个值比较是否相等则遵循:val1 == val2，两个值可能不是一个类型数据，如果是==比较的话，会进行默认的数据类型转换
* 对象 == 布尔类型，对象先转换为字符串(toString),然后再转换为数字(Number),布尔类型也转换为数字(true是1，false是0)，然后让两个数字比较
* 对象 == 数字，对象先转换为字符串(toString),然后再转换为数字(Number)，然后再进行比较
* 数字 == 布尔，布尔转换为数字再进行比较
* 数字 == 字符串，字符串转换为数字再进行比较
* 字符串 == 布尔，都转换为数字再进行比较
* 对象 == 字符串，先将对象转换为字符串(调用toString的方法)，然后再进行比较,[]转换为字符串就是"",{}转换为字符串"[object Object]"
* 对象 == 对象，永远不相等
* null == undefined，结果是true
* null或者undefined和其他任何数据类型比较都不相等
* NaN == NaN 永远不相等

## 数据类型的区分和数据类型的检测

### 基本数据类型和引用数据类型的区别

* 基本数据类型是把值直接给了变量，接下来在操作过程中，直接拿这个值操作，可能两个变量存储的值是一样的，但是互相之间是没有任何关系的，其中一个改变另外一个没有任何影响
* 引用数据类型：定义一个变量，然后开辟一个新的空间，然后把属性名和属性值保存在这个空间中，并且产生了一个空间地址，然后把这个地址给了这个变量，变量并没有储存这个数值而是这对这个空间的引用地址，接下来把这个空间地址给了另外一个变量，另外一个变量储存的也是这个地址，此时两个变量操作的是同一个空间，所以其中一个变量改变，另一个也会跟着改变
* 基本数据类型和引用数据类型最本质的区别就是：基本数据类型操作的是值，而引用数据类型操作的是对新空间的引用地址

### 检测数据类型的方式

* typeof 运算符
* instanceof 运算符
* constructor
* Object.prototype.toString.call()

### typeof运算符

* typeof运算符用来检测数据类型 
* typeof 要检查的值，返回值:一个字符串，包含了数据类型字符"number","string","boolean","undefined","object","function"
* typeof null的结果是"object"
* typeof undefined的结果是"undefined"
* typeof的局限性：不能具体的检查object下细分的类型，检查这些返回的都是"object"
* 出现两个和两个以上typeof的时候，最终结果都是"string"

### instanceof
 
* instanceof运算符用来判断已知对象是否属于某个类的实例,因为每种数据类型都有自己所属的类
* 能详细检测引用数据类型,对于基本数据类型只有通过构造函数方式创建的才能检测

### constructor(构造)

* constructor和instanceof功能类似

### Object.prototype.toString.call()

* 用来检测数据类型属于哪些数据类型中的哪一类
